import { GoogleGenAI, Type } from "@google/genai";
import { Song, SongSearchResult, Instrument } from "../types";
import { sanitizeInput } from "../utils/security";

// Initialize Gemini Client
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Searches for songs based on a query.
 * This simulates a search index by asking the AI for popular matches.
 */
export const searchSongs = async (query: string): Promise<SongSearchResult[]> => {
  try {
    const sanitizedQuery = sanitizeInput(query);
    const response = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents: `Search for popular songs matching the query: "${sanitizedQuery}". Return a JSON list of up to 5 best matches.`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              title: { type: Type.STRING },
              artist: { type: Type.STRING },
              id: { type: Type.STRING, description: "A unique slug, e.g. artist-song-name" },
            },
            required: ["title", "artist", "id"],
          },
        },
      },
    });

    return JSON.parse(response.text || "[]");
  } catch (error) {
    console.error("Error searching songs:", error);
    return [];
  }
};

/**
 * "Scrapes" (Generates) the chords and lyrics for a specific song and instrument.
 * It instructs the AI to act as a database of chords.
 */
export const getSongData = async (
    songId: string, 
    title?: string, 
    artist?: string, 
    instrument: Instrument = 'guitar'
): Promise<Song> => {
  // Sanitize inputs
  const safeTitle = title ? sanitizeInput(title) : undefined;
  const safeArtist = artist ? sanitizeInput(artist) : undefined;
  const safeId = sanitizeInput(songId);

  // If we don't have title/artist (e.g. loading from ID), we ask the AI to infer it or just provide the data.
  const promptContext = safeTitle && safeArtist ? `${safeTitle} by ${safeArtist}` : `the song with ID ${safeId}`;

  // Tailor prompt for the instrument
  let instrumentInstruction = "";
  if (instrument === 'ukulele') {
    instrumentInstruction = "Provide the chords specifically for Ukulele (standard GCEA tuning).";
  } else if (instrument === 'piano') {
    instrumentInstruction = "Provide the chords for Piano/Keyboard. You may include bass note indications (e.g., C/G) where appropriate.";
  } else {
    instrumentInstruction = "Provide standard Guitar chords.";
  }

  try {
    const response = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents: `Provide the ${instrument} chords and lyrics for ${promptContext}. 
      ${instrumentInstruction}
      Format the content as a standard text chord sheet where chords are placed above the lyrics.
      Also determine the key of the song.
      Do not include any conversational text, just the chord sheet.
      `,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            title: { type: Type.STRING },
            artist: { type: Type.STRING },
            key: { type: Type.STRING, description: "The musical key of the song, e.g. G, Am" },
            content: { type: Type.STRING, description: "The full text body with chords above lyrics" },
          },
          required: ["title", "artist", "key", "content"],
        },
      },
    });

    const data = JSON.parse(response.text || "{}");
    
    return {
      id: songId,
      title: data.title || title || "Unknown Title",
      artist: data.artist || artist || "Unknown Artist",
      key: data.key || "C",
      content: data.content || "Could not generate content.",
      chords: {
          [instrument]: data.content
      },
      source: "Generated by AcordesAI"
    };
  } catch (error) {
    console.error("Error fetching song details:", error);
    throw new Error("No se pudo obtener el cifrado.");
  }
};